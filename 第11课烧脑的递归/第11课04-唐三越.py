#参照无数帖子,找到一个用现有知识可以解决的方法,理解消化累si
#柱子碍眼
# -----------------------------导入库-----------------------------
from turtle import *
# -----------------------------定义函数-----------------------------

def hanoi(n, a, b, c):  #原理部分见我上一个作业
    if (n==1):
        move(a, c)
    else:
        hanoi(n - 1, a, c, b)   #递归,换参
        move(a, c)
        hanoi(n - 1, b, a, c)

def move(a, b):
    m = towers[a].pop() # A塔列表尾部(最上面)的小盘子(Turtle对象)删除，并取出
    m.goto(dz_X[b], len(towers[b]) * 20)  # --->  Turtle对象（即盘子).goto()
    '''移动取出的小盘子
    len(towers[b]) * 20则代表目标柱子的纵坐标。
    这个纵坐标的计算方法是将目标塔的盘子数量（len(towers[b])）乘以20'''
    towers[b].append(m)
    '''这行代码将这个已经移动到目标柱子的Turtle对象（即盘子）
    添加到目标塔的列表的尾部。
    在汉诺塔问题中，这代表将盘子放到目标柱子上。'''

n=5  #自适应
towers = [[], [], []] # 三个塔的[]
dz_X=[-200,0,200] # 三个塔的横坐标
# -----------------------------初始化第一个塔-----------------------------
for i in range(n): 
    t = Turtle()
    '''  ↑  t现在成了一支画笔,画笔形状是长方形(砝码)
    在每次循环时，这个代码行都会被执行，因此每次循环都会创建一个新的Turtle对象。
每个Turtle对象都有自己的位置、方向、形状、颜色等属性，
因此通过在每次循环时创建新的Turtle对象，
可以实现在屏幕上绘制不同位置和形状的图形。'''

    t.up()
    t.color('black', 'yellow')
    t.shape('square')
    t.shapesize(1, n - i)# (宽,横高)   列表头部是最大的盘子，尾部是最小的盘子
    t.goto(dz_X[0], i * 20)

    towers[0].append(t)
    '''  ↑  把乌龟放入第一个塔这个语句并不会立即在屏幕上显示任何东西。
它只是将乌龟对象添加到了列表中。
要实际看到乌龟在屏幕上移动或绘图，你需要使用其他turtle命令

第一次看到还能这么玩,我吃惊了半天'''

# ---------------------------------------------------------
hanoi(n, 0, 1, 2)



'''具体看作业三:这里的0，1，2是三个塔的标识，对应着初始的三个塔。在递归调用中，
这三个标识会被改变以保证所有的盘子都能从a移动到c。
具体的工作原理是先把(n-1)个盘子从a通过c移动到b，
然后把最大的盘子从a移动到c，最后把(n-1)个盘子从b通过a移动到c。-->整体法'''

'''done()
用来阻止画笔窗口在程序结束后自动关闭。
如果你想让窗口保持打开状态以便你可以看到你的图形或动画

反正是这么解释的,但加不加好像都一样'''
